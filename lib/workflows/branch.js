const core = require('@actions/core');
const exec = require('@actions/exec');
const github = require('@actions/github');
const utils = require('../utils');

PULL_REQUEST_TEMPLATE = `
This PR was auto generated by the \`licensed-ci\` GitHub Action.
It contains updates to cached \`github/licensed\` dependency metadata to be merged into \`<base>\`.

If updates are unexpected, please check the \`github/licensed\` [changelog](https://github.com/github/licensed/tree/master/CHANGELOG.md) for recent updates.

<statusMessage>
<details>
<summary>Log</summary>

\`\`\`
<log>
\`\`\`
</details>

<prComment>

/cc @<actor>
`.trim();

STATUS_MESSAGES = {
  true: 'All status checks succeeded, please merge when ready.',
  false: 'There are reported status failures, please fix all logged errors before merging.'
};

async function createLicensesPullRequest(octokit, head, base, statusResult) {
  const actor = process.env.GITHUB_ACTOR;
  const prComment = core.getInput('pr_comment');
  if (prComment) {
    core.warning('"pr_comment" is deprecated.  Please use the "pr_url" and "pr_number" step outputs to script additional actions on the created pull request.');
  }
  const body = PULL_REQUEST_TEMPLATE.replace('<prComment>', prComment)
                                    .replace('<base>', base)
                                    .replace('<statusMessage>', STATUS_MESSAGES[statusResult.success])
                                    .replace('<log>', statusResult.log)
                                    .replace('<actor>', actor);

  const { data: pull } = await octokit.pulls.create({
    ...github.context.repo,
    title: `License updates for ${base}`,
    head,
    base,
    body
  });

  await octokit.pulls.createReviewRequest({
    ...github.context.repo,
    pull_number: pull.number,
    reviewers: [actor]
  });

  core.info(`Created pull request for changes: ${pull.html_url}`);
  return pull;
}

function getLicensesBranches(branch) {
  if (branch.endsWith('-licenses')) {
    return [branch, branch.replace('-licenses', '')];
  }

  return [`${branch}-licenses`, branch];
}

async function status() {
  const { command, configFilePath } = await utils.getLicensedInput();

  let log = '';
  const options = {
    ignoreReturnCode: true,
    listeners: {
      stdout: data => log += data.toString()
    }
  };

  const exitCode = await exec.exec(command, ['status', '-c', configFilePath], options);
  return { success: exitCode === 0, log };
}

async function run() {
  let licensesUpdated = false;
  let pullRequestCreated = false;

  const branch = utils.getBranch();
  const [licensesBranch, userBranch] = getLicensesBranches(branch);
  core.setOutput('licenses_branch', licensesBranch);
  core.setOutput('user_branch', userBranch);

  // // find an existing pull request, if one exists
  const token = core.getInput('github_token', { required: true });
  const octokit = new github.GitHub(token);
  let pullRequest = await utils.findPullRequest(octokit, licensesBranch, branch);

  // check whether cached metadata needs any updating
  let statusResult = await status();
  if (statusResult.success) {
    if (branch !== licensesBranch && core.getInput('cleanup_on_success', { required: true }) === 'true') {
      // delete the licenses branch if it exists
      // the action doesn't deal well with reusing previous branches
      core.info('License checks succeeded. Cleaning up branches and PRs');
      await utils.closePullRequest(octokit, pullRequest);
      await utils.deleteBranch(licensesBranch);
    }

    return;
  }

  // recache data only when on a non-licenses branch
  if (branch !== licensesBranch) {
    const { command, configFilePath } = await utils.getLicensedInput();

    // change to a `<branch>/licenses` branch to continue updates
    await utils.ensureBranch(licensesBranch, branch);

    // ensure that branch is up to date with parent
    let exitCode = await exec.exec('git', ['merge', '-s', 'recursive', '-Xtheirs', parent], { ignoreReturnCode: true });
    if (exitCode !== 0) {
      throw new Error(`Unable to get ${branch} up to date with ${parent}`);
    }

    // cache any metadata updates
    await exec.exec(command, ['cache', '-c', configFilePath]);

    // stage any changes, checking only configured cache paths if possible
    const cachePaths = await utils.getCachePaths(command, configFilePath);
    await exec.exec('git', ['add', '--', ...cachePaths]);

    // check for any changes, checking only configured cache paths if possible
    exitCode = await exec.exec('git', ['diff-index', '--quiet', 'HEAD', '--', ...cachePaths], { ignoreReturnCode: true });
    if (exitCode > 0) {
      // if files were changed, push them back up to origin using the passed in github token
      const commitMessage = core.getInput('commit_message', { required: true });
      await exec.exec('git', ['commit', '-m', commitMessage]);
      await exec.exec('git', ['push', utils.getOrigin(), licensesBranch]);
      licensesUpdated = true;

      if (!pullRequest) {
        statusResult = await status();
        pullRequest = await createLicensesPullRequest(octokit, licensesBranch, branch, statusResult);
        pullRequestCreated = true;
      }
    }

    await exec.exec('git', ['checkout', branch]);
  }

  core.setOutput('licenses_updated', licensesUpdated.toString());

  // set the PR url and number to output if one exists
  if (pullRequest) {
    core.setOutput('pr_url', pullRequest.html_url);
    core.setOutput('pr_number', pullRequest.number);
    core.setOutput('pr_created', pullRequestCreated.toString());
  }

  // fail if initial check didn't succeed
  throw new Error('Cached metadata checks failed');
}

module.exports = run;
