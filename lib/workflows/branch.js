const core = require('@actions/core');
const exec = require('@actions/exec');
const github = require('@actions/github');
const utils = require('../utils');

PULL_REQUEST_TEMPLATE = `
This PR was auto generated by the 'licensed-ci' GitHub Action.
It contains updates to cached 'github/licensed' dependency metadata to be merged into \`<base>\`.

If updates are unexpected, please check the github/licensed [changelog](https://github.com/github/licensed/tree/master/CHANGELOG.md) for recent updates.

<statusMessage>
<details>
<summary>Log</summary>

\`\`\`
<log>
\`\`\`
</details>

<prComment>
`.trim();

STATUS_MESSAGES = {
  true: 'All status checks succeeded, please merge when ready.',
  false: 'There are reported status failures, please fix all logged errors before merging.'
};

async function ensureLicensesPullRequest(octokit, head, base, statusResult) {
  const { data } = await octokit.search.issuesAndPullRequests({
    q: `is:pr is:open repo:${process.env.GITHUB_REPOSITORY} head:${head} base:${base}`
  });

  if (data.total_count > 0) {
    // an open PR from the licenses branch to the parent branch exists
    return;
  }

  const actor = process.env.GITHUB_ACTOR;
  const prComment = core.getInput('pr_comment');
  const body = PULL_REQUEST_TEMPLATE.replace('<prComment>', prComment)
                                    .replace('<base>', base)
                                    .replace('<statusMessage>', STATUS_MESSAGES[statusResult.success])
                                    .replace('<log>', statusResult.log);

  const { data: pull } = await octokit.pulls.create({
    ...github.context.repo,
    title: `License updates for ${base}`,
    head,
    base,
    body
  });

  await octokit.pulls.createReviewRequest({
    ...github.context.repo,
    pull_number: pull.number,
    reviewers: [actor]
  })

  core.setOutput('branch-pr-url', pull.html_url);
  core.setOutput('branch-pr-number', pull.number);
  core.info(`Created pull request for changes: ${pull.html_url}`);
}

function getLicensesBranch(branch) {
  if (branch.endsWith('-licenses')) {
    return branch;
  }

  return `${branch}-licenses`;
}

async function status() {
  const { command, configFilePath } = await utils.getLicensedInput();

  let log = '';
  const options = {
    ignoreReturnCode: true,
    listeners: {
      stdout: data => log += data.toString()
    }
  };

  const exitCode = await exec.exec(command, ['status', '-c', configFilePath], options);
  return { success: exitCode === 0, log };
}

async function run() {
  const branch = utils.getBranch();
  const licensesBranch = getLicensesBranch(branch);

  // check whether cached metadata needs any updating
  let statusResult = await status();
  if (statusResult.success) {
    return;
  }

  // recache data only when on a non-licenses branch
  if (branch !== licensesBranch) {
    const { command, configFilePath } = await utils.getLicensedInput();

    // change to a `<branch>/licenses` branch to continue updates
    await utils.ensureBranch(licensesBranch, branch);

    // cache any metadata updates
    await exec.exec(command, ['cache', '-c', configFilePath]);

    // stage any changes, checking only configured cache paths if possible
    const cachePaths = await utils.getCachePaths(command, configFilePath);
    await exec.exec('git', ['add', '--', ...cachePaths]);

    // check for any changes, checking only configured cache paths if possible
    const exitCode = await exec.exec('git', ['diff-index', '--quiet', 'HEAD', '--', ...cachePaths], { ignoreReturnCode: true });
    if (exitCode > 0) {
      // if files were changed, push them back up to origin using the passed in github token
      const commitMessage = core.getInput('commit_message', { required: true });
      const token = core.getInput('github_token', { required: true });
      const octokit = new github.GitHub(token);

      await exec.exec('git', ['commit', '-m', commitMessage]);
      await exec.exec('git', ['push', 'licensed-ci-origin', licensesBranch]);

      statusResult = await status();
      await ensureLicensesPullRequest(octokit, licensesBranch, branch, statusResult);
    }

    await exec.exec('git', ['checkout', branch]);
  }

  // fail if initial check didn't succeed
  throw new Error('Cached metadata checks failed');
}

module.exports = run;
