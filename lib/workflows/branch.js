const core = require('@actions/core');
const exec = require('@actions/exec');
const github = require('@actions/github');
const utils = require('../utils');

PULL_REQUEST_TEMPLATE = `
This PR was auto generated by the \`licensed-ci\` GitHub Action.
It contains updates to cached \`github/licensed\` dependency metadata to be merged into \`<base>\`.

If updates are unexpected, please check the \`github/licensed\` [changelog](https://github.com/github/licensed/tree/master/CHANGELOG.md) for recent updates.
`.trim();

// Create a pull request for the licenses branch
async function createLicensesPullRequest(octokit, head, base) {
  const actor = process.env.GITHUB_ACTOR;
  const body = PULL_REQUEST_TEMPLATE.replace('<base>', base);

  const { data: pull } = await octokit.pulls.create({
    ...github.context.repo,
    title: `License updates for ${base}`,
    head,
    base,
    body
  });

  await octokit.pulls.createReviewRequest({
    ...github.context.repo,
    pull_number: pull.number,
    reviewers: [actor]
  });

  core.info(`Created pull request for changes: ${pull.html_url}`);
  return pull;
}

NOTIFY_STATUS_TEMPLATE = `
The \`licensed-ci\` GitHub Action updated cached license metadata based on changes to <parent>.

**\`licensed status\` result: <status>**
<statusMessage>

\`\`\`
<log>
\`\`\`

<prComment>

/cc @<actor>
`.trim();

STATUS = {
  true: "SUCCEEDED",
  false: "FAILED"
};

STATUS_MESSAGES = {
  true: 'All status checks succeeded, please merge when ready.',
  false: 'There are reported status failures, please fix all logged errors before merging.'
};

// Create a comment on the licenses PR giving an update on the latest status
async function notifyStatus(octokit, userBranch, licensesPullRequest, statusResult) {
  const actor = process.env.GITHUB_ACTOR;
  const prComment = core.getInput('pr_comment');
  if (prComment) {
    core.warning('"pr_comment" is deprecated.  Please use the "pr_url" and "pr_number" step outputs to script additional actions on the created pull request.');
  }
  const body = NOTIFY_STATUS_TEMPLATE.replace('<prComment>', prComment)
                                     .replace('<status>', STATUS[statusResult.success])
                                     .replace('<statusMessage>', STATUS_MESSAGES[statusResult.success])
                                     .replace('<log>', statusResult.log)
                                     .replace('<actor>', actor)
                                     .replace('<parent>', userBranch);
  await octokit.issues.createComment({
   ...github.context.repo,
   issue_number: licensesPullRequest.number,
   body,
  });
}

NOTIFY_USER_TEMPLATE = `
The \`licensed-ci\` GitHub Action has <action> a [pull request](<pr url>) containing license metadata updates based on the changes in this branch.

Please review the pull request for any additional changes required and merge when ready.
`.trim();

ACTIONS = {
  true: 'created',
  false: 'updated'
};

// Create a comment on the user's PR notifying that updates were made to the
// licenses branch/PR
async function notifyUser(octokit, branch, licensesPullRequest, created) {
  const body = NOTIFY_USER_TEMPLATE.replace('<pr url>', licensesPullRequest.html_url)
                                   .replace('<action>', ACTIONS[created]);

  const pullRequest = await utils.findPullRequest(octokit, { head: branch, "-base": branch });
  if (pullRequest) {
    await octokit.issues.createComment({
     ...github.context.repo,
     issue_number: pullRequest.number,
     body,
    });
  }
}

function getLicensesBranches(branch) {
  if (branch.endsWith('-licenses')) {
    return [branch, branch.replace('-licenses', '')];
  }

  return [`${branch}-licenses`, branch];
}

async function status() {
  const { command, configFilePath } = await utils.getLicensedInput();

  let log = '';
  const options = {
    ignoreReturnCode: true,
    listeners: {
      stdout: data => log += data.toString()
    }
  };

  const exitCode = await exec.exec(command, ['status', '-c', configFilePath], options);
  return { success: exitCode === 0, log };
}

async function run() {
  let licensesUpdated = false;
  let pullRequestCreated = false;

  const branch = utils.getBranch();
  const [licensesBranch, userBranch] = getLicensesBranches(branch);
  core.setOutput('licenses_branch', licensesBranch);
  core.setOutput('user_branch', userBranch);

  // // find an existing pull request, if one exists
  const token = core.getInput('github_token', { required: true });
  const octokit = new github.GitHub(token);
  let licensesPullRequest = await utils.findPullRequest(octokit, { head: licensesBranch, base: branch });

  // check whether cached metadata needs any updating
  let statusResult = await status();
  if (statusResult.success) {
    if (branch !== licensesBranch && core.getInput('cleanup_on_success', { required: true }) === 'true') {
      // delete the licenses branch if it exists
      // the action doesn't deal well with reusing previous branches
      core.info('License checks succeeded. Cleaning up branches and PRs');
      await utils.closePullRequest(octokit, licensesPullRequest);
      await utils.deleteBranch(licensesBranch);
    }

    return;
  }

  // recache data only when on a non-licenses branch
  if (branch !== licensesBranch) {
    const { command, configFilePath } = await utils.getLicensedInput();

    // change to a `<branch>-licenses` branch to continue updates
    await utils.ensureBranch(licensesBranch, branch);

    // ensure that branch is up to date with parent
    let exitCode = await exec.exec('git', ['merge', '-s', 'recursive', '-Xtheirs', `origin/${branch}`], { ignoreReturnCode: true });
    if (exitCode !== 0) {
      throw new Error(`Unable to get ${licensesBranch} up to date with ${branch}`);
    }

    // cache any metadata updates
    await exec.exec(command, ['cache', '-c', configFilePath]);

    // stage any changes, checking only configured cache paths if possible
    const cachePaths = await utils.getCachePaths(command, configFilePath);
    await exec.exec('git', ['add', '--', ...cachePaths]);

    // check for any changes, checking only configured cache paths if possible
    exitCode = await exec.exec('git', ['diff-index', '--quiet', 'HEAD', '--', ...cachePaths], { ignoreReturnCode: true });
    if (exitCode > 0) {
      // if files were changed, push them back up to origin using the passed in github token
      const commitMessage = core.getInput('commit_message', { required: true });
      await exec.exec('git', ['commit', '-m', commitMessage]);
      await exec.exec('git', ['push', utils.getOrigin(), licensesBranch]);
      licensesUpdated = true;

      if (!licensesPullRequest) {
        licensesPullRequest = await createLicensesPullRequest(octokit, licensesBranch, branch);
        pullRequestCreated = true;
      }

      statusResult = await status();
      await notifyStatus(octokit, branch, licensesPullRequest, statusResult);
      await notifyUser(octokit, branch, licensesPullRequest, pullRequestCreated);
    }

    await exec.exec('git', ['checkout', branch]);
  }

  core.setOutput('licenses_updated', licensesUpdated.toString());

  // set the PR url and number to output if one exists
  if (licensesPullRequest) {
    core.setOutput('pr_url', licensesPullRequest.html_url);
    core.setOutput('pr_number', licensesPullRequest.number);
    core.setOutput('pr_created', pullRequestCreated.toString());
  }

  // fail if initial check didn't succeed
  throw new Error('Cached metadata checks failed');
}

module.exports = run;
